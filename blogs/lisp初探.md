# lisp初探

`lisp`

## 函数的表达方式
Lisp语言的是一种函数式语言。所谓函数是说，它的语句就像数学中的函数表达式的作用是一样的。 虽然概念一样，然而在表达上还是有些出入的。

在数学中，我们会这样表示一个函数
```
f(x)
```
同样的函数，在Lisp中我们会这样表示：
```
(f x)
```
在数学中，函数是一个函数名，后面跟着一个括号，括号里面装着参数。但在 LISP 中，整个函数表达式用括号括起来，第一个元素是函数的名称，后面跟着函数的参数。

如果是有两个参数（在一些立体几何的函数中就会有这样的例子），比如
```
z=f(x,y)
```
聪明的你们应该可以猜出来是这样写的：
```
(f x y)
```
因为加法符号的可以看成是一个二元函数，所以，我们可以这样写：
```
+(1,1)
```
那么，写成 LISP 的形式，就是
```
(+ 1 1)
```
现在，你知道为什么数学表达式中运算符要放在最前面了吧。

复合函数如：
```
f(g(x))
```
在 LISP 中会写成
```
(f (g x))
```
在Lisp中，表达式是很重要的概念。你每次输入的表达式，都会被求值。

我们可以尝试一下 LISP 中自带的函数
```
(sqrt 9)
```
sqrt 表示开方的意思，这句话的意思就是对9开方，返回的结果自然是3了。
```
(log 16 2)
```
这句话表示求以2为底16的对数。

## 逻辑运算
逻辑运算，就是关于真假的运算，我们应该先习惯 LISP 的语法，那么 3<4 该如何写呢？
```
(< 3 4)
```
上面这个式子的结果是
```
T
```
在 LISP 中，T 代表逻辑真，而 NIL 代表逻辑假。暂且不用太追究名称的由来，后面我会告诉你的。

接下来，尝试一个逻辑与表达式：
```
(and T T)
```
就是真且真为真。

或的英语翻译是OR。
```
(OR T NIL)
```
顺带告诉大家，在Lisp中大小写不重要。

最后来个最复杂的
```
(or (> 3 4) (> 4 2))
```
## 表和原子[编辑]
Lisp的全名叫“表处理语言”，LISt Procesor 。可见表在Lisp中的重要性。

简单说来，用小括号括起来的表达式式就叫表。

比如：

(+ 1 2)
就是一个表。

而表里面的东西，就是原子。比如上面的这个表里，+ 是原子，1 是原子，2 也是原子。

原子就是不包含空格的符号，可以是字符，也可以是数字。比如，下面的这个表里，有两个原子。

'(hello world)
这两个原子分别是 hello 和 world。

其实，上面的那个式子，也是 LISP 语言中的 hello world 程序。很简单，对吧。不过别忘记括号前面的单引号，否则会报错。

表里不仅可以包含原子，也可以包含另一个表。举个例子：
```
(or (> 3 4) (> 4 2))
```
在上表中，or是原子，而 `(> 3 4) `、`(> 4 2) `都是表，不是原子。当然了，这两个小表里，包含的东西都是元素。

也就是说：表是可以嵌套的。

表的大小并没有限制，最小的表就是空表：
```
()
```
## 程序和数据
编程这项工作，是在写一个程序，而写程序的目的是为了处理数据。程序与数据是编程中的两大要素，而在 Lisp 中，这两者都用 表 来表示。

如果你在解译器中输入一个表，那么Lisp会对这个表求值。所以在解释器中输入
```
(+ 1 2)
```
会打印3。

说明这个表的值是3。

我们再看一个例子：
```
(1 2 3)
```
如果你在解释器中输入上面的表达式，会得到一个错误：`Error: 1 is invalid as a function.` 意思是1不是一个可用函数。

在所有的表中，第一个原子总是函数，代表操作、指令、命令。而之后原子（或表）是参数，意即对操作的说明。所以 `(+ 1 2)` 表示 `1 + 2`，而 `(- 4 3) `表示 `4 -3`。

例外是这个
```
()
```
这是一个空表，会返回
```
NIL
```
NIL是一个原子，表示逻辑假，但它同时也是空表。它是LISP语言中唯一一个既是表又是原子的东西。

程序是表，那数据该如何表示？ 数据也是用表来表示。

Lisp会对所有的表求值，但如果我们想使用表本身（作为数据），这反而会成为一件麻烦事。只要用一个简单的操作符就可以防止求值，那就是 ' 操作符（单引号）。
```
'(+ 1 2)
```
这次解译器不对这个表其求值了，结果不再是3这个原子，而是一个表，原封未动的表。
```
(+ 1 2)
```
还记得我们的 hello world 程序吗?
```
'(Hello world!)
```
会返回
```
(HELLO WORLD!)
```
各种程序语言的入门书籍都喜欢一个hello, world程序。在此郑重告诉大家， Lisp 也有自己的 Hello，world！

上面我们输入的是小写的字母，输出的却是大写的字母。这是因为在 Lisp 中大小写无所谓。

不过 ' 这个东西其实只是一个语法糖（为了让程序员少打几个字符而创造的语法）。它其实是一种简写，全称是quote操作，意思是引用。上面的hello world 程序如果写全了，就是：
```
(quote (Hello world!))
```
## DEFUN 操作符
DEFUN操作符用来自定义函数，形式如下

(defun 函数名原子 参数名列表 执行列表)

比如
```
(defun 2nd (x)
  (car (cdr x))
)
```
这样，我们就定义了一个函数，就像我们之前接触的很多操作符一样。这个函数的名称是 2nd，而它的作用就是 返回一个列表的第二个元素。

这个函数的名称后面是一个列表 (x) ，表示这个函数只接受一个x作为参数。紧接着是另一个列表 (car (cdr x))，表示这个函数作用于 x 身上就如同这个表达式的作用一样，返回值也是这个表达式作用于 x 之后的值。

让我们应用一下这个元素。
```
(2nd '(1 2 3))
```
会返回 2

函数的定义式中，有个x，是函数的参数，上面的这个函数的执行过程就相当于
```
(car (cdr '(1 2 3)))
```
## 参数
参数就是我们第一个定义中的x，参数的个数是没有限制的。比如
```
(defun lianjie (x y)
  (append x y)
)
```
这个函数的作用是连接两个表，因为它执行的是append函数。

##系统自带的函数
系统自带了很多函数，比如下面这两个函数：
First函数
```
(first '(1 2 3))
1
```
返回参数列表的第一个所组成的值。

## Last函数[编辑]
```
(last '(1 2 3))
（3）
```
没错，last函数的作用就是返回参数列表的最后一个所组成的表。注意，返回的是一个列表而不是一个原子。

第一个自定义函数
我们将要定义一个函数 ends，它的作用是返回参数列表的头尾两个元素组成的列表。

如何实现呢，我们首先取出参数列表的第一个元素，然后取出最后一个元素，再将两者连在一起就行了。这要用到我们之前提到的 first 函数和 last 函数。
```
(defun ends (x) 
  (cons (first x) (last x))
)
```
这样，我们就定义完成了这个函数。分析一下定义体中的 (cons (first x) (last x)) 这是要连接两个元素，第一个元素是 x 的第一个元素，第二个元素是 last 函数所取出的表。其结果自然就是x的头和尾两个元素所组成的列表。

我们来试验一下：
```
(ends '(1 2 3))
(1 3)
```
上面的这个例子中，关键的一步相当于 `(cons 1 '(3))` 。

## ATOM 函数
前面已经讲过了，用来判断一个表达式是不是原子


```
>(atom (+ 1 1))

T

>(atom '(3))

NIL
```
因为2是原子，而（3）是个表。

## NULL 函数
NULL函数用来判断表达式的值是不是NIL。


```
>(null nil)

T

>(null (car '(3)))

NIL
```
## EQUAL 函数
用来判断两个表达式的值是否完全相等


```
>(equal 's 's)

T

>(equal '(s) '(s))

T
```

## 七大公理

Lisp有7个基本操作符（实际上或许可以再精简）。这7个基本操作符就像几何中的公理一样，任何其他函数都可以由这七大公理定义。也就是说，7个基本操作符包含了Lisp的所有语义。

这7个基本操作符是：

* Quote
* Atom
* Eq
* Car
* Cdr
* Cons
* Cond

## 使用公理造一些简单的轮子

NULL函数
NULL函数用于检测表是否为空，或者元素是否为nil。
```
(defun null2 (x) (cond ((equal x nil) t) (t nil)))
```
解释：如果参数与nil相等，就返回t，否则返回nil。这和逻辑学上的not函数是一致的（但null函数的应用范围更广，因为它可以应用于表）。

And函数
```
>(defun and2 (x y) (cond ((equal x nil) nil) ((not (equal y nil)) t) (t nil)))
```
Or函数
```
>(defun or2 (x y) (cond ((equal x t) t) ((equal y t) t)))
```
Last 函数的表示
```
>(defun last2 (x) (cond ((equal (cdr x) nil) x) (t (last2 (cdr x)))))
```
Length函数的表示
下面讲如何计算一个表x的长（即元素个数）度。

```
>(defun len (x) (cond ((null x) 0) (t (+ (len (cdr x)) 1))))
```
递归式是(len (cdr x)) ，终结条件是(null x)为真。

Append函数的表示
设参数形式是x和y。很容易分析出来，递归式是(cons (car x) (append2 (cdr x) y))，终结条件是当x为NIL时，返回y。

```
>(defun append2 (x y) (cond ((eq x nil) y) (t (cons (car x) (append2 (cdr x) y)))))
```
Equal函数的表示
设参数形式是x和y。很容易分析出来，递归式是(equal (cdr x) (cdr y))，递归条件是(equal (car x) (car y))，终止条件是(equal (cdr x) nil)或者(equal (cdr y) nil)或者((atom x) (equal x y))

```
(defun equal2 (x y) 
  (cond 
    ((null x) (not y))
    ((null y) (not x))
    ((atom x) (eq x y))
    ((atom y) (eq x y))
    ((not (equal2  (car x) (car y))) nil)
    (t (equal2 (cdr x) (cdr y)))
  )
)
```
代码解释：
```
   ((null x) (not y))
```
首先，如果x为空，说明遇到了x列表的末尾，这时检测y列表是否也到了，如果到了（此时我们知道之前的元素都相等），那么返回真，否则返回假。

```
   ((null y) (not x))
```
如果y到了末尾，一样处理。

```
   ((atom x) (eq x y))
```
如果x是一个原子，说明函数是从(equal2 (car x) (car y))字句进入的，且(car x)的结果为原子。这时函数就可以结束了，返回x=y的结果。

```
   ((atom y) (eq x y))
```
如果y是一个原子，说明函数是从(equal2 (car x) (car y))字句进入的，且(car y)的结果为原子。这时函数就可以结束了，返回x=y的结果。

```
   (t (equal2 (cdr x) (cdr y)))
```
否则的情况，我们就递归。

总结，大家可以发现，其实这个函数的递归路径有两个。

If函数的表示[编辑]
用cond可以实现if函数。实际上，在类c语言中，if语句强调的是程序的走向，但在Lisp中，程序的走向可以忽略（从某种意义上），而强调的是返回值。

```
>(defun if2 (p e1 e2)
 (cond (p e1) (t e2))
 )

IF2
```

## get cli for debian
```
sudo apt-get install clisp
```

from [lisp wikibook](https://zh.wikibooks.org/wiki/Lisp_%E5%85%A5%E9%96%80)
